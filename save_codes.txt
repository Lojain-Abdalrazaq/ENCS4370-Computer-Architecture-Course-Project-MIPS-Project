compress_decompress: .asciiz "\n Choose (c),(compress),(compression) for compression and (d),(decompress),(decompression) for decompression and (q) for Quit: "
operations_path: .asciiz "\n Enter the path of the file to be compressed or decompressed:"
dict_exist: .asciiz "\n The dictionary.txt exist."
dict_notexist: .asciiz "\n The dictionary.txt does not exist."
newline: .ascii "\n"


    # Find the newline character in the string
    la $t0, input     # Load the address of the input string to $t0
    la $t1, newline   # Load the address of the newline character to $t1

    find_newline:
        lb $t2, ($t0)    # Load a byte from the input string
        beqz $t2, end    # Break if the byte is null (end of string)
        beq $t2, $t1, replace_newline   # If the byte is a newline, go to replace_newline
        addi $t0, $t0, 1   # Increment the input string pointer
        j find_newline




# after deleteing the \n, here we will check if the input path is valid or not 
	bne $v0, 0, invalid_file_path    # if the value of $v0 is not 0, then the file does not exist
	# if the path is valid -> then we will load the dictionary file inout to data structure.
	# open the file, and load the contenet strings to the word buffer



--> "C:\Users\Ho182\Downloads\input.txt"

---------------------------------
.data
fileName: .asciiz "dictionary.txt"  # File name to create

.text
main:
    # Open file for writing (create if it doesn't exist)
    li $v0, 13          # system call for open file
    la $a0, fileName    # address of null-terminated string containing filename
    li $a1, 9           # O_WRONLY | O_CREAT | O_TRUNC flags
    li $a2, 0           # mode (not used when creating a file)
    syscall             # open a file
    move $s0, $v0       # save the file descriptor

    # Check if file creation was successful
    bgez $s0, fileCreated
    # File creation failed, handle the error or display a message
    j fileCreationFailed

fileCreated:
    # File creation successful
    # ...

# File creation failed handler
fileCreationFailed:
    # Error handling code goes here
    # ...

# ...





----
.data
str_exit: .asciiz "test.txt"
str_data: .asciiz "This is a test!"
str_data_end:

.text

file_open:
    li $v0, 13
    la $a0, str_exit
    li $a1, 1
    li $a2, 0
    syscall  # File descriptor gets returned in $v0
file_write:
    move $a0, $v0  # Syscall 15 requieres file descriptor in $a0
    li $v0, 15
    la $a1, str_data
    la $a2, str_data_end
    la $a3, str_data
    subu $a2, $a2, $a3  # computes the length of the string, this is really a constant
    syscall
file_close:
    li $v0, 16  # $a0 already has the file descriptor
    syscall

------------
.data
str_exit: .asciiz "C:\Users\Ho182\Downloads\input.txt"
str_data: .asciiz "This is a test!"
str_data_end:

.text

file_open:
    li $v0, 13
    la $a0, str_exit
    li $a1, 1 
    li $a2, 0
    syscall  # File descriptor gets returned in $v0
file_write:
    move $a0, $v0  # Syscall 15 requieres file descriptor in $a0
    li $v0, 15
    la $a1, str_data
    la $a2, str_data_end
    la $a3, str_data
    subu $a2, $a2, $a3  # computes the length of the string, this is really a constant
    syscall
file_close:
    li $v0, 16  # $a0 already has the file descriptor
    syscall




---> NOW, THE 2-D ARRAY 
a[0] Aseel
a[1] Lojain


# if the file does not exists, then create the file 'dictionary.txt'.
ans_is_no:
  	# Open (for writing) a file that does not exist
  	li   $v0, 13       # system call for open file
  	la   $a0, create_dict_file     # output file name
  	li   $a1, 1        # Open for writing (flags are 0: read, 1: write)
  	li   $a2, 0        # mode is ignored
  	syscall            # open a file (file descriptor returned in $v0)
        move $s0, $v0      # save the file descriptor 
  	# Write to file just opened
  	li   $v0, 15       # system call for write to file
        move $a0, $s6      # file descriptor 
        la   $a1, empty_file  # address of buffer from which to write
        li   $a2, 44       # hardcoded buffer length
        syscall            # write to file
  	# Close the file 
  	li   $v0, 16       # system call for close file
  	move $a0, $s6      # file descriptor to close
        syscall 
    	#bgez $v0, FileCreated   # if the file is created succefully, then go to the next step
        j Copress_Or_Decompress


#######################################################################################################
STARTING WITH READING THE DICTIONARY FILE TO THE ARRAY
# Store the string in the array
    la $t1, myArray          # Address of the array
    addu $t1, $t1, $t0       # Calculate the destination address in the array
    move $t2, $a1            # Copy the source address (buffer) to $t2
    sb $zero, ($t1)          # Store the null character at the beginning of the destination
    store_loop:
        lb $t3, ($t2)        # Load a character from the source
        sb $t3, 1($t1)       # Store the character in the destination (starting from offset 1)
        addiu $t1, $t1, 1    # Increment the destination address
        addiu $t2, $t2, 1    # Increment the source address
        bnez $t3, store_loop # Loop until null character encountered
    addiu $t0, $t0, 9        # Increment the index by the string length

    j read_loop              # Continue reading the next string



	li $v0,13 # system call for opening the file
	la $a0, create_dict_file
	li $a1,1   # write only mode
	syscall
	move $s0,$v0    # saving the file descriptor
	li $v0, 16   # close the file mode
	move $a0,$s0   #s
	syscall



#################################
#---------------------------------------------- DECOMPRESSION TEST FILE ----------------------------------------------#
.data
.align 4
dicttArray: .space 256           # intialzing the array with 256 size (approximation)
filename:   .asciiz "/Users/Ho182/Downloads/dictionary.txt"   # the compressed file path
buffer:     .space 64            # Buffer to store a single string


.text
.globl main
main:
	# filrstlt, we have to open dictionary file to save it into the array
	li $v0, 13               # system call to open the file
	la $a0, filename         # address of the string that contains the file path
	li $a1, 0                # for the flag
	li $a2, 0                # for the mode 
	syscall
	
read_dictionary_loop:	
	move $s0,$v0 # save the file descriptor in $s0
	                         # reading the file
	li $v0, 14               # System call code for reading from a file
    	move $a0, $s0            # File descriptor to read from
   	la $a1, buffer           # Address of the buffer to store the string
	li $a2, 264               # 64 --> referes to the maximum number of characters to read (adjust as needed)
	syscall
	# Check if end of file or error occurred
   	beqz $v0, done_reading   # If returned value = 0, end of file reached or error occurred
   	
   	# now, we want to store every string in oyr array -> dicttArray
   	la $t1, dicttArray         # Address of the array
   	addu $t1, $t1, $t0       # Calculating the destination address  --> the index of the out array to store the string in it
   	move $t2, $a1            # Copy the source address (buffer --> that we save every single string in it ) to $
   	sb $zero, ($t1)          # Store the null character at the beginning of the destination *******IDK WHY
   	
   	store_loop:
        lb $t3, ($t2)        # Load a character from the source
        sb $t3, 1($t1)       # Store the character in the destination (starting from offset 1)
        addiu $t1, $t1, 1    # Increment the destination address
        addiu $t2, $t2, 1    # Increment the source address
        bnez $t3, store_loop # Loop until null character encountered
    	addiu $t0, $t0, 9        # Increment the index by the string length
   	
   	# keep iteration in the loop until we finish all the content of the input file
   	j read_dictionary_loop
	
		
done_reading:
 	# Close the file to avoid any problem
        li $v0, 16               # System call code for closing a file
        move $a0, $s0            # File descriptor to close
        syscall
        ############################ HERE I WILL PRINT THE VALUE OF THE ARRAY TO MAKE SURE THE OPERATION DONE CORRECTELY*****
	j QuitProgram
	
# exiting the whole program   
QuitProgram:  
	li $v0, 10  # system call to exit the whole program
	syscall


------DECOMPRESSION APPROACH 
# this file will do the logic of decompression 
# i think the main stpes: 
	# 1. read the dict.txt and save it in an 2d-array called arr
		# 1.a here i should save the number of the lines in the file.  
	# 2. read the compress file and each line we read convert it from string to int 
	# 3. each number we read compare it with the line numbers from point #1.a
		# 3.a if the read number is more than the number of lines, then print error message, exit
		# 3.b else, take the value as this arr[readnumber][world buffer]
		# and print it in a file called decompressed file 
	# 4. repate the loop till the end of the compress file.
		